const PAGE_DATA = {
    level: "Level 6",
    title: "Objects",
    lessons: [{title:"this", objective:"Objective: To figure out what 'this' is.", description:"Sometimes, an object needs to refer to itself.<br /><br />Let's say we have a button and when the user clicks the button, we want the text on that button to change. No big deal. We give it an id, grab it using getElementById(), and change the text.<br /><br />But what if this is the only thing we do with this button and we don't need a global variable?  What if we want to pass the button object into a function when it is clicked, do our thing, and be done with it?<br /><br />We would use <b><i>this</i></b>.<br /><hr />",slides:[{text:"Let's start in Javascript.<br /><br />The changeMyColor() function will take an HTML element (brought it through the parameter 'el') and change the text color to the color specified by the parameter 'clr'.<br /><br />What's nice about this function is that it's an abstract tool that can work with any element.  We haven't written any HTML and we don't know which element we want to change, nor do we know the color we want to change it to.",image:"step1.PNG"},{text:"This function expects that the call to it will pass an HTML element into el and a color value into clr.<rb /><br />The color value can come in any form (mnemonic, hex, or rgb()), as long as it's a string.<br /><br />Since el is an HTML element object, we can use it to access the style object belonging to that element.",image:"step2.PNG"},{text:"el <b><i>is</i></b> an HTML object. Up until this point, all of our Javascript representations of HTML objects have come through getElementById(). Now one is coming in as a parameter, but it's <b><i>still</i></b> an HTML object and is used just the same way any other HTML object is used.",image:"step2.PNG"},{text:"So let's write some HTML. When we are finished with this, the user will be able to click on the div and turn the text red.<br /><br />Try to contain your excitement.",image:"step3.PNG"},{text:"Embedding the function call into an onclick works even for a div.  You can click on anything and have it respond.<br /><br />The big thing here is the first argument.  <b><i>this</i></b>.  As described, it is a way to refer to an object FROM WITHIN the object.  Since our function call is embedded in the div, any reference to <b><i>this</i></b> is a reference to that individual div.<br /><br />Try it.",image:"step4.PNG"},{text:"To further illustrate this point, add a second div, but give it the same function call.  We changed the color to a hex value, but the first argument is still <b><i>this</i></b>.  Since it's a different div, though, it's a different <b><i>this</i></b>.<br /><br />That's it for now.",image:"step5.PNG"}]},
{title:"Custom Objects", objective:"Objective: To understand how to add and change the properties of an object.", description:"In applications languages, objects come from templates, often called classes. While Javascript has classes, you can also create an empty object and just start adding properties to it.<br /><br />When dealing with complex data, you need to work with objects. Think about how impossible it would be to work with HTML and Javascript together if the elements weren't objects.<br /><br />Now consider a page that reads in data from a database. It doesn't matter what kind of data. Each item of data will come with multiple and various pieces of information. Without objects, storing and accessing that information becomes exponentially harder.<br /><hr />",slides:[{text:"Before beginning this project, make sure you set up a separate folder so that everying this nice and contained.<br /><br />The next thing you should do is download the <a href = 'lessons/custom objects/dragon images.zip'>Dragon Images Zip File</a> and extract that into your folder.<br /><br />Then set up your index.html file with the following HTML code and make sure all of the images show up properly.<br /><br />At first, this will look very much like our old image gallery, but we're going to be adding captions and using objects.",image:"step1.PNG"},{text:"Add some CSS to make the display workable. You can put this in the style tag, as illustrated, or you can make a separate CSS file and link it if you like.",image:"step2.PNG"},{text:"When all is said and done, there won't be a lot of code.  What's important about this construction is how all of the code comes together. These concepts will open doors to creating complex and dynamic pages.<br /><br />Almost everything is going to happen in initialize() so watch the code for the changes.",image:"step3.PNG"},{text:"There are 6 dragons so we're going to work with an array.  In initialize, we create an empty array that we will ultimately fill using a loop.",image:"step4.PNG"},{text:"Our dragons are going to consist of a name and an image element.  Normally, data would come from a database or some import file, but we don't have access to any of that.  We're just going to mimic that data by making an array of names.",image:"step5.PNG"},{text:"Instead of using getElementById() to grab each individual image element, this program uses <b><i>getElementsByClassName()</i></b>.<br /><br />This function works very similary to getElementById() but instead of grabbing a single element based on the value of its id, it creates and returns a list of all of the elements that share the specified class name.<br /><br />This list is not technically an array, but it behaves very similarly to an array so we'll ignore the distinction for now.",image:"step6.PNG"},{text:"Now we're going to loop.  Inside this loop, we'll put together all of the pieces of information that we've manufactured into objects.<br /><br />Notice that we're using the length of dragonImages to determine the length of the loop.  We could have just as easily used the length of DRAGON_NAMES since those 2 lists are parallel.  The only thing that is not recommended (and strongly discouraged) is using a fixed number.  That would limit your program to the exact number of dragons we've specified.",image:"step7.PNG"},{text:"During each iteration of the loop, we are going to create an empty object and store it in the array.  In order to create an empty object, just assign it some empty braces({}).  This syntax may seem out of place, but it isn't.  Braces are used to create blocks of code (functions, conditionals, loops, etc...). When you create a class or a template that is a block of code.  What makes the object different is that we can update it on the fly.",image:"step8.PNG"},{text:"The next step is to add properties to the object.  This is NOT tricky at all.  In fact, the syntax is very intuitive.  Since we use the dot (.) to access properties, it only follows that we should use the dot (.) to assign properties.<br /><br />You can assign a new property to any object just that same way you would create any variable.  Instead of...<br /><br /><b><i>x = 3;</i></b><br /><br />you have...<br /><br /><b><i>someObject.x = 3;</i></b>",image:"step9.PNG"},{text:"It's important to understand that, through this code, we are not building a single object, but an <i>array</i> of objects.  That's why each object is specified by dragon[i].  As the loop continues, a new item is added to the array and that item is an object.",image:"step9.PNG"},{text:"The dragonName property gets its value from the corresponding item in the DRAGON_NAMES array.  Again, this is just pseudo-data used to illustrate the technique.  Normally, data would come from some external source.<br /><br />The second property is actually an HTML element.  We are associated a particular back end object with its front end representation.  That will save us time and code when we're displaying.",image:"step9.PNG"},{text:"This last line of code closes the connection between the front end element and the back end object.  It takes the image element and creates a new property for it.  That property is our dragon object.<br /><br />Let's make a point of that.  We took an existing HTML image element and gave it a brand new property on the fly.  We did that by using the dot operator.<br /><br />The conclusion you should be drawing is that the dot operator, which gives us access to an object's properties and functions, also gives us access to <b><i>create</i></b> properties and functions for an object.",image:"step10.PNG"},{text:"By making this association, it gives us the power to let the user input inform the back end about which object is being manipulated.<br /><br />The function calls added to the images pass in <b><i>this.dragon</i></b>. We alread know that <b><i>this</i></b> is the image object.  That means <b><i>dragon</i></b> is a property of the image object.  And, in fact, it's the property we created in the last step.<br /><br />That means that we are passing the dragon object associated with that image back into the selectDragon() function.",image:"step11.PNG"},{text:"In this sample program, the selectDragon() function just updates the display.  Using the dragon object passed in, it can update the image and the caption for the dragon's name.  Of course, in a larger setting, the concept of creating these connections can help us save lots of time and code in trying to figure out which front end interactive elements connect to which back end objects.",image:"step12.PNG"}]},
{title:"Modular Code", objective:"Objective: To experience a piece of code that is adaptable and portable.", description:"The definition of abstract is, 'existing in thought or as an idea but not having a physical or concrete existence'.<br /><br />That concept goes so against the grain of human thinking that it's a wonder it ever made it into society.<br /><br />Think about it. If you are asked to define something, how often is it your first instinct to give an example instead of a definition? A definition is abstract. An example is concrete.<br /><br />And yet, we absolutely need it in order to program computers. Everything we create in code is a <b><i>representation</i></b> of something rather than an <b><i>example</i></b> of it.  When you write code, you should be thinking about it's overall purpose rather than a specific function. You should design it to serve that purpose under myriad conditions, making it adaptable and responsive.<br /><hr />",slides:[{text:"Let's expand on the concept from the last lesson.  We want to build a data gallery, something with an image, a caption, and some explanatory text. But we want this data gallery to be usable with any properly formatted data that we can feed it.<br /><br />This simple HTML construction is designed to respond to the data. It's got a place for a title, and image, a caption, and some information about the image.<br /><br />There are also slots for 3 thumbnails.  The gallery may have more than 3 images associated with it, but the arrows will allow us to scroll through them and select the ones that we want.<br /><br />All of the images are included in the <a href = 'lessons/modular code/gallery images.zip'>Gallery Images Zip File</a>.",image:"step1.PNG"},{text:"Here's some basic CSS to make the page a little more visually appealing. It's just the basics. Ultimately, you'll want to create your own CSS that can display the items in a way that you want.",image:"step2.PNG"},{text:"In initialize(), we start off by capturing the HTML elements we'll need to edit throughout the course of the program.<br /><br />The currentImgIdx will tell us which item to display.  The offset is going to compensate for there being only 3 thumbnails displayed.<br /><br />After adding this code, create the 'itemdata.js' file and open it for editing.  The next step is to put some code into that.",image:"step3.PNG"},{text:"This data gallery is designed to work with a file called itemdata.js.  That file, no matter what kind of data it holds, must conform to the format that we are setting up for it.  It must include a pageTitle and an itemList.<br /><br />The pageTitle is just a string.<br /><br />The itemList is an array objects in JSON (pronounced jason) format.",image:"step4.PNG"},{text:"JSON stands for JavaScript Object Notation<br /><br />It's a quick way for us to write objects in Javascript without having to go line by line. JSON is actually used in many languages because it can be ported into a program as a string and parsed into an object or converted from an object back into a string.<br /><br />The format for a JSON object is as follows:<br /><br /><b>{property1:'value1', property2:'value2', ..., propertyN:'valueN'}</b><br /><br />As you can see, you can create as many 'property:value' pairs as you like, creating very simple to very complex objects.",image:"step4.PNG"},{text:"If you look closely at the code, our itemList is an array of JSON objects.  Each of the objects includes the properties:  itemName, itemInfo, and itemImage.  Each of the properties has an associated value.",image:"step4.PNG"},{text:"The display() function will draw the information for the currently selected object.  Therefore, it will access itemList by the currentItemIdx index.<br /><br />currentItemIdx was originally set to 0 so the first item from the datafile will be shown when the page loads.  The value of currentItemIdx will change every time a new item is selected.<br /><br />We haven't programmed the thumbnails yet, but you can load this up and see the first dragon.",image:"step5.PNG"},{text:"Remember that our page supports 3 thumbnails, but our data gallery supports a virtually unlimited number of items.  We handle this by having a 'scrolling' list of thumbnails.<br /><br />This means that only 3 are shown at a time, starting with the one representing the item at index 'offset'.<br /><br />The loop goes from 0 to the number of thumbnails (which is 3, but you could have theoretically made as many as you like).  When assigning the src, though, it uses the offset to adjust the index so that a user can scroll through the images.<br /><br />If the offset is 0, the page will show images 0 - 2. If the offset is 1, it will show 1 - 3, etc...",image:"step6.PNG"},{text:"Every time the user clicks on one of the arrows, the offset will move either forward or backward by one.  The moveOffset() function will handle that movement.<br /><br />This function will only change the offset variable (and make sure it doesn't go out of bounds).  The display() function is actually already designed to handle those changes.",image:"step7.PNG"},{text:"The offset variable keeps track of which item to show FIRST in the list of thumbnails.<br /><br />The first step is to change it by mod.  Based on our function calls from the arrows, mod will either be 1 or -1.",image:"step8.PNG"},{text:"If the offset goes out of bounds, readjust it to match either of the boundaries.<br /><br />The end of the boundary has to be adjusted by 3 because the page is designed to show 3 images.  Therefore, if you push the offset passed the length of the array - 3, you'll wind up with an error.<br /><br />If the number of images was variable, the offset boundary would have to be variable as well.<br /><br />You should be able to scroll through the images now.",image:"step9.PNG"},{text:"Here, we've added onclicks to the 3 thumbnails.<br /><br />Notice the parameters. These numbers seem like they correspond to indices, but you have to remember that the first thumbnail may <b><i>not</i></b> correspond to the first item in the array because of scrolling.<br /><br />That's where offset comes in.  If you don't remember that, go back a couple of steps to the display and look at it again.",image:"step10.PNG"},{text:"We use offset again here in the display.<br /><br />The use of offset here is absolutely essential because the user will see 3 thumbnails on screen.  Each thumbnail passes through its own index (0, 1, or 2) into idx.  Unless the first 3 items in the array are showing, the index passed will not match the index of the item in the list.  The offset tells us the difference between the index passed in and the actual index of the item.<br /><br />Your data gallery should be complete now.",image:"step11.PNG"}]},
{title:"The DOM", objective:"Objective: To understand how the DOM is organized.", description:"Before going into the construction, take a look at the <a href = 'lessons/the dom/Elements of the DOM.pptx'>Elements of the DOM Powerpoint</a>. This will give you an overview of what's going on a web page.",slides:[{text:"For this construction, we're going to create a simple program where a user can flip the top card off of a deck.  You can download the <a href = 'lessons/the dom/cardimages.zip'>Card Images zip file</a>.<br /><br />There are several constants associated with this program.<br /><br />The deck is created by calling the generateStandardDeck() function.",image:"step1.PNG"},{text:"The generateStandardDeck() function runs a 2 dimensional loop (through ranks and then through suits).<br /><br />Through each iteration, a temporary card object is created and assigned properties based on the position in the loop.<br /><br />The card images have been named to work with this format.",image:"step2.PNG"},{text:"In the HTML, all we need is an image for clicking.  We'll use the card back for that.  Don't worry about the call to flipCard().  We'll write that function in a few steps.<br /<br />The div is going to get all of our new images as the cards are flipped.",image:"step3.PNG"},{text:"Add the flippedCardContainer object to initialize() function.  This div is going to serve as the landing place for all of our new card images.",image:"step4.PNG"},{text:"The flipCard() function is called every time the user clicks on the deck.  It's job will be to remove the first card from the array and put it on screen.  In order to do that, the function will have to create a brand new image element and set its src to match the card's image name.",image:"step5.PNG"},{text:"Don't draw a card off of the deck if there are no cards in the deck.  You'd be surprised just how important this is.",image:"step6.PNG"},{text:"Next, pull the top card off of the deck.  We store it in a temporary variable (card).  That object is no longer in the array.  Once this function ends, we will lose all reference to the object.",image:"step7.PNG"},{text:"Now comes the fun part.<br /><br />The first thing we need is a brand new image element.  New elements can be created with the document.createElement() function.  Just pass the name of the tag into the function as an argument.<br /><br />The function returns the element, which we store in a temporary variable.  Because it's an image, we can set its src.",image:"step8.PNG"},{text:"We want to insert our new image element onto the page inside of flippedCardContainer.  The appendChiled() function exists for every HTML Element that can have children (no self-closing tags).  It takes in an element as a parameter and updates the page accordingly.<br /><br />Try it. When you're done, go to the War Card Game sample and have a look at that.  Give yourself an opportunity to think about how you would go about writing that game and maybe even try it before looking at the code.",image:"step9.PNG"}]},
{title:"Javascript Classes", objective:"Objective: For every object, there is a template that defines that object.", description:"When I was a kid, there was an arcade game called <i>Berserk</i><br /><br />One player. A jillion robots.<br /><br />You could put a jillion robots into an array.  That gives us flexibility with the number of robots.  But what's a robot?  What is a robot made of?<br /><br />At the very least, each robot needs an X and Y coordinate.  That's already 2 variables for you one object and you can bet there are more.<br /><br />That's where classes come in.  If my program needs to make robots, then my program first needs to know <i>how</i> to make robots.<hr />",slides:[{text:"Custom objects start with a template or a prototype or a class.  All of those words are synonmous so you can use them interchangeably.<br /><br />In Javascript, that prototype is built through a function.<br /><br />Notice that this function's name begins with a capital letter.  Though, again, the browser doesn't care, this is pretty standard so that your classes stand apart from your other functions.",image:"step1.PNG"},{text:"The Animal function is referred to as a <b><i>constructor</i></b>.  It's the function that will be used to define what an Animal is and how an Animal works.<br /><br />In this context, the 'this' keyword refers to <i>this</i> Animal.  What that means is that every Animal object will use this Animal function.  'this' tells us which Animal object is currently doing that.",image:"step2.PNG"},{text:"In order to understand how to build classes and objects, you need to understand the distinction between a <b><i>class</i></b> and an <b><i>object</i></b>.<br /><br />Animal, as we are defining it, is a class.  It defines the structure for building Animal objects.  In a way, it is <i>all</i> Animals.<br /><br />mightyJoe is an Animal obect, as defined by the use of the keyword 'new'.<br /><br />If you look at this line of code, it says:<br /><br />Create a variable called mightJoe.<br />The assigned value will be a <i>new</i> instance of an Animal.<br />Pass in 'Joe' as an argument.<br /><br />When the Animal constructor is called, 'Joe' is passed into 'n' and 'n' is assigned to 'this.name'.  That means that the specific instance of that Animal object has now been assigned 'Joe' as the value for its 'name' property.",image:"step3.PNG"},{text:"We can now access the property of the object by using the dot operator.  If you want to have a quick look at mightJoe's name, run this code and check the console.",image:"step4.PNG"},{text:"Different objects can be built from the same class and have different properties for their values.  When you access those properties with the specific objects, you get the individualized values.<br /><br />Try this.",image:"step5.PNG"},{text:"Just to be sure, look at the Animal constructor again.<br /><br />The keyword 'this' is essential to this process.  When we created mightyJoe, 'this' was mightyJoe.  When we created kodo, 'this' was kodo.<br /><br />Though you only code the class once, each time an object is made from it, a new <b><i>instance</i></b> is stored in memory.  That instance has all of the information for that particular object.  Access to that object is unique and individualized.  'this' is the universal reference for that object inside the class code.",image:"step2.PNG"},{text:"Let's add another property.  The location will tell us where the animal is at any time.<br /><br />Notice that both of these properties are initialized by the values passed into the parameters.  This is a very basic example.  You will find that there are times when you create properties that have specific initial values and don't need parameters.",image:"step6.PNG"},{text:"Let's update our Animal objects.  You can take out the logs.  We're going to make a zoo.",image:"step7.PNG"},{text:"Here is the basic HTML for our zoo.  All we want to do is be able to make some Animals and show them in a list.",image:"step8.PNG"},{text:"Start with the basics.  We need HTML element objects so that we can manipulate the page on the fly.<br /><br />We need an array for our animals.  Since we wouldn't want to lose Joe and Kodo, we'll put them into the array.<br /><br />Notice how Joe and Kodo are added <i>anonymously</i> into the array.  This means that we didn't have to store them into variables first.  The <i>new instance</i> is just placed in the array and the array's index is the reference.",image:"step9.PNG"},{text:"When working with objects in an array, remember that each item of the array IS one of those objects.  That's why animalList[i] can use the dot operator to access name and location.  It is an Animal.<br /><br />Notice how we use the first item in the array to initialize listOutput.innerHTML.  This is just a little styling trick.  We can now start the loop at 1 and concatenate a <br /> at the beginning of each of their outputs so that we have one animal per line and no hanging <br /> at the end.<br /><br />Try it.  You should see Joe and Kodo.",image:"step10.PNG"},{text:"Now onto the heart of the page, adding Animals.<br /><br />This first bit of code prevents the user from creating Animals with no names and/or locations.  It checks the inputs and flashes a warning if there's nothing there.<br /><br />For those of you who haven't seen an <b><i>alert</i></b> before, it's a function that belongs to the 'window' object.  It creates a dialog box on screen with a message.<br /><br />Try to trigger the alert.",image:"step11.PNG"},{text:"Push the new animal into the array.  Once again, there's no reason to create temporary variables when the whole thing can be pushed into the array anonymously.<br /><br />The new Animal is the object.<br /><br />The values from the name and location text boxes are the properties.",image:"step12.PNG"},{text:"Clear out the input boxes, which makes it easier to add a new animal next.<br /><br />...and display().<br /><br />Try it.",image:"step13.PNG"},{text:"Programs are built piece by piece.  Right now we have a working program, but we want to add some functionality.<br /><br />Let's add an Update button and a Delete button.",image:"step14.PNG"},{text:"In order for us to be able to delete or update animals, we need to be able to reference them.  Since we opted <i>not</i> to use HTML elements as containers for the animals, a click interface is out of the question.  What we do have, however, are indices.<br /><br />Create a numeric box that allows the user to enter an index.  This number will be ignored when adding the animal, but it will be referenced when deleting an animal.",image:"step15.PNG"},{text:"Let's start the deleteAnimal() function.  The first thing we need to do is grab the animal's index from the box.  We'll use this index to find the right animal in the array and take it out.",image:"step16.PNG"},{text:"Next, if the index is represented in the list, just splice that animal out.<br /><br />You can try this function now.  It should work.  Always make sure something's working before moving on to the next thing.",image:"step17.PNG"},{text:"The updateAnimal() function takes bits from both the deleteAnimal() function and the addAnimal() function.<br /><br />First, it makes all of the same error checks.",image:"step18.PNG"},{text:"Once that's out of the way, you can just change the object's values at the selected index and display.<br /><br />Try it now.",image:"step19.PNG"},{text:"I know you think we should be done, but take a look at updateAnimal(), deleteAnimal(), and addAnimal().<br /><br />They share code.<br /><br />Shared code should be shared, not repeated.",image:"step19.PNG"},{text:"Let's take the code that checks for values in the input boxes and turn it into its own function.<br /><br />This function will check the boxes and return true if there's something in both boxes and false if there isn't.<br /><br />These kinds of boolean checks are common and can be streamlined in numerous ways.",image:"step20.PNG"},{text:"Let's take a minute to review how <i>return</i> statements work.<br /><br />Remember that they end a function.  In this case, that makes the else extranneous. If the condition triggers, the function will return true and end.<br /><br />Only if it doesn't trigger will it be able to move on and return false.<br /><br />So we saved a line of code.<br /><br />But just one line.",image:"step21.PNG"},{text:"If you think about it, an if conditional runs on a boolean expression.  Therefore, the condition inside is either evaluating to true or false.  If it's true, we return true.  If it's false, we return false…<br /><br />Since that is the case, why not simply return the value of the boolean expression itself?  This function will still either return true or false.",image:"step22.PNG"},{text:"We can now go back to addAnimal() and replace the code that checks for the values with a simple call to our new function.  If it returns false, then we do nothing in addAnimal().",image:"step23.PNG"},{text:"Let's build a function for our other error checking code, the one that checks to see if the index is legitimate.<br /><br />This function needs to know which index is being checked.  That means it needs a parameter.<br /><br />Like valuesEntered(), it returns a boolean value based on a condition.  Like valuesEntered(), we can simply return the value of that boolean expression.",image:"step24.PNG"},{text:"Now, in deleteAnimal(), we can replace our error checking with a simple call to the animalInList() function.",image:"step25.PNG"},{text:"Finally, in updateAnimal(), we can replace both error checks with calls to the functions.<br /><br />If either of them is true, then the we cannot update and we end the function.<br /><br />This is done now.  Make sure it works.<br /><br />When you're comfortable with this, have a look at Bootem Inc. in the samples section.",image:"step26.PNG"}]},
{title:"Prototypes", objective:"Objective: To understand the depth of classes through the use of prototypes.", description:"When you think about a prototype in JavaScript, you shouldn't think of it in terms of objects, but rather in terms of classes. Every function has a prototype. If you build the function into a class, that prototype grows.<br /><br />By accessing the prototype, you can build all kinds of functionality into your classes. And you're not just limited to variables and functions.<br /><br />You can copy whole classes.  If you copy the prototype of Class X to Class Y, you essentially make Class X a part of Class Y.  Then you can add to Class Y and give it its own identity with Class X as part of that identity.<br /><br />I know.  It's a lot.",slides:[{text:"For this construction, we're going to do something very basic in a very fancy way.  We're going to build a deck of cards and lay them all out on the table.  Shuffled.<br /><br />Make a separate file for your playing card classes and call it 'playingcards.js'.<br /><br />When you begin a class, you need to have an idea of what your final product is going to look like.  What do you want to build?<br /><br />A playing card is a familiar construct so all we need to do is figure out how we're going to represent the parts of the card.<br /><br />The answer is numerically.<br /><br />These constants will give value to the familiar ranks and suits that are not inherently numerical.",image:"step1.PNG"},{text:"We've played with card objects in a previous tutorial by adding properties on the fly.  Here, we're creating a class structure.<br /><br />The Card() function pulls in values for the rank, suit, and image.",image:"step2.PNG"},{text:"This is a CardDeck.  It's really just a container or a wrapper for an array of Card objects.  It may seem silly to have to create the CardDeck class when we can just put the Cards into an array, but…",image:"step3.PNG"},{text:"...with an object, you can create your own functions.  Every class has a prototype, which is the template of its parts.  We can add to that template by accessing the prototype directly.<br /><br />Here, we're adding something called shuffleDeck to the prototype and defining it as a function.",image:"step4.PNG"},{text:"Now we can implement the shuffleDeck() function.  There are a number of different shuffling algorithms, but the most efficient one involves putting random cards into a temporary array and then making the temporary array permanent.<br /><br />Let's just start with the temporary array.",image:"step5.PNG"},{text:"Now comes the loop.  We're going to pull cards out of the deck <b><i>while</i></b> there are cards in the deck.<br /><br />'this' referes to the CardDeck object calling the suffleDeck() function.",image:"step6.PNG"},{text:"The best way to get something out of an array is to splice it out.  We can use splice to take 1 random card out of the deck and put it into tmpCard.<br /><br /><i>Since this function is using</i> getRandomInteger()<i>, rememeber to include your utilities.js file in your HTML file </i>before<i> including the playingcards.js file.</i> ",image:"step7.PNG"},{text:"The thing about splice is that it, itself, returns an array.  Even though we only took out 1 card.<br /><br />So we have an array with one card in it.<br /><br />So we have to access that card.<br /><br />Since there's only one, it has to be at index 0.  All the time.",image:"step8.PNG"},{text:"Take some time look at that splice and make sure that you understand how it works.  When you're absolutely sure, push the card into the temporary deck.",image:"step9.PNG"},{text:"And when all is said and done, make the temporary deck the permanent one.<br /><br />Remember that arrays are objects.  Since objects carry a lot of information, they have to be strung out across memory.  What's really stored in an object variable is a <b><i>memory address</i></b> that tells the computer where to look for the information.<br /><br />When we copy tmpDeck into this.deck, we're really copying the address for all of that data.  Therefore, the permanent deck (this.deck) now <b><i>points</i></b> to the new data.",image:"step10.PNG"},{text:"Now that our objects are complete, let's build a card deck.  There are many different types of decks you might want to create, based on the type of game(s) you want to write.  Even with a standard deck of cards, there are games that use fewer cards or double decks or whatever.  We're going to stick with a standard deck of 52 cards.<br /><br />I know what you're thinking.  You've done this before.  With classes and prototypes, it'll differ slightly.",image:"step11.PNG"},{text:"The first thing we need is a CardDeck object (see? It's already different).  We're going to fill this deck with cards and then return it.<br /><br />This function's job is specifically to create a card deck and return it so that a program using it can manufacture it at will.",image:"step12.PNG"},{text:"Creating a deck is all about creating the 52 cards.  We could do that one card at a time, but it's much more efficient to code it using a double loop.  Since everything is by the numbers, 'for' loops work the best.<br /><br />The outer loop will cycle through the ranks.  The inner loop will cycle through the suits.  If this were reversed, the only difference would be the order in which the cards were entered into the deck.<br /><br />For each rank (13 ranks), we are going to work with each suit (4 suits), which will give us 52 cards.",image:"step13.PNG"},{text:"Inside the inner loop, the card is created and pushed into the temporary card deck.<br /><br />The Card template takes 3 parameters, the rank (r), the suit (s), and the image name (built from the rank and the suit).<br /><br />Our card deck is named 'deck'.  Every card deck has an array as a property.  That array is also named 'deck'.  That's why we have the line 'deck.deck.push(...)'.",image:"step14.PNG"},{text:"Finally, the completed deck is returned.",image:"step15.PNG"},{text:"Create an 'index.html' file for this and set it up as shown.<br /><br />Remember to import utilities.js and playingcards.js.<br /><br />We're going to show all of the cards in the single div.<br /><br />In initialize(), the card deckk is created by assiging a global variable the value returned by generateStandardDeck().<br /><br />Finally, we'll call showDeck, which will handle the output of the entire deck of cards.",image:"step16.PNG"},{text:"In this function, we're going to pull all of the cards out of the deck and display them on screen.  The loop will continue to create image objects and put cards into them for as long as there are cards in the deck.<br />br />It will be annoying accessing the deck array through the deck all the time.<br /><br /><b><i>maybe there's something we can do about that...</i></b>",image:"step17.PNG"},{text:"...but not right now.<br /><br />For right now, let's stick with what we have and create some images.  We'll ultimately append the images to the div, but in between, we'll need to grab a card and update the image's src with it.",image:"step18.PNG"},{text:"Pull the card off of the deck and store it in a temporary variable.  Since tmpCard is a Card object, it has, as a property, an imageFilename.  We can build that into the src of the image object.  This should work now.<br /><br /><b><i>The code shown assumes all of the images are in a folder called 'cardimages'.  If you have your directory structure set up differently, remember to adjust your code accordingly.</i></b>",image:"step19.PNG"},{text:"You should have seen the entire deck, in the order that it was made.  Now try it with shuffling.",image:"step20.PNG"},{text:"Okay, let's do something about that deck.deck reference.<br /><br />One of the things you can do with a prototype, is copy one from one class to another class.  This is great when you start building classes that expand upon other classes.  This is a concept called inheritance.  Inheritance is a tremendously powerful cornerstone of object oriented programming, but it doesn't really get a lot of play in Javscript.  Part of the reason is because Javascript is not built to really handle the most powerful aspects of inheritance.<br /><br />Here, though, by copying the prototype from Array, a Javascript class that we use all of the time (I know we define them using the bracket shortcut instead of the class name, but there it is), we can turn our CardDeck into an Array.",image:"step21.PNG"},{text:"This has some fantastic applications, not the least of which being that we now have access to all of the Array functions that we've grown fond of using.  However, what you may have missed is that we have <b><i>literally</i></b> turned our CardDeck into an array.  Because of that, we no longer need the deck variable.<br /><br />This is going to have some real impact on the rest of the program.",image:"step22.PNG"},{text:"Take a look at the old shuffleDeck function.  It has to undergo some drastic changes.<br /><br />Remember that we took out deck.  A CardDeck is now an array.  That means that tmpDeck must also be a CardDeck instead of a straight up array.",image:"step23.PNG"},{text:"All of our references to 'deck' need to go away now, too.  There is no more 'deck'.  The CardDeck object is the array.  'this' is the array.<br /><br />Notice how 'this' can now access all of the array functions directly.<br /><br />The last line, though, is going to cause a problem.  You cannot assign a value to 'this'.  There are no exceptions to this rule.  This code will not work.",image:"step24.PNG"},{text:"That means we need an alternative way of making the temporary deck the permanent deck.<br /><br />While we could loop through the temporary deck and copy everything back into 'this', there's another way.  The written statement uses the 'push' function as an object so that it can call apply().  Apply is a function that takes the items from an array and applies them as individual pieces of information for a function.<br /><br />So, in this example, if we used push() directly, it would take the whole tmp array and add it to 'this' as a single element.<br /><br />By using apply(), it breaks down tmp, item by item, calling push() for 'this' on each item.  Therefore, each item gets added separately.",image:"step25.PNG"},{text:"For generateStandardDeck(), all we need to do is remove the one reference to the deck array inside of our CardDeck (because it's gone).",image:"step26.PNG"},{text:"Finally, you've got a couple of references to the deck array in showDeck().  Just take those out and you should be good to go.",image:"step27.PNG"}]}],
    samples: [{title:"War Card Game", lesson:"The Dom", text:"War is a game where two players each take half of a standard deck of cards.  During each round, each player flips over the top card of their deck.  The player with the highest card (Ace is highest) collects both cards and places them on the bottom of their deck.  If both cards have the same rank, then there is a war.  Each player should deal out 3 cards face down and then a fourth card face up.  Whichever player has the highest 4th card wins the war and collects all of the cards.  If both fourth cards are the same, run another war (and so on).  The game is over when one player has collected all of the cards."}, {title:"Bootem Inc", lesson:"JavaScript Classes", text:"Bootem Inc is a program that simulates a company and its employees.  The program creates a set of 250 fictional employees with IDs, ages, salaries, and years of service all manufactured according to the program's specifications.<br /><br />The user can play with the program by defining retirement packages for employees."}, {title:"Catalogue Engine", lesson:"Modular Code", text:"The Catalogue Engine is a page that shows a series of products, sorted by category.  The user will be able to click on a category name to see the items from that category.  They can then click on the arrows to scroll through the items to view each one."}],
    faq: [{question:"I see arrays online that use strings instead of numbers for indices.  What's that all about?",answer:"You can use the syntax of an array to access the properties of an object.<br /><br />I know. That doesn't make any sense. An index in an array is a number but the properties of an object are words. But, look.<br /><br />I have a dragon. His name is Drake.<br /><br /><b>dragon.dragonName = 'Drake';</b><br /><br />I can access his name through the dot operator.<br /><br /><b>someElement.innerHTML = dragon.dragonName;</b><br /><br />I can also access his name as if it was an index in an array.  I just reference the property name as if it were a string.<br /><br /><b>someElement.innerHTML = dragon['dragonName'];</b><br /><br />If I wnt to be even more absurd, I can create a string variable that has the property name as its value and use that string variable to access the property.<br /><br /><b>nameStr = 'dragonName';<br />someElement.innerHTML = dragon[nameStr];</b><br /><br />Pretty cool, right?"}, {question:"How can I convert JSON objects to strings and JSON strings to objects?",answer:"Each language has its own functionality for using JSON objects.  In Javascript, there are 2 important functions:<br /><br />The function JSON.stringify(obj) will return obj, an object, as a JSON string.<br /><br />The function JSON.parse(str) will return str, a JSON formatted string, as an object."}, {question:"What is inheritance?",answer:"JavaScript doesn't have true inheritance, but we can get pretty close with prototypes. That's what we did with the CardDeck.<br /><br />Think of inheritance as a way to take something abstract and break it down, class after class, into some specifics.<br /><br />Let's say we have a Vehicle class and all Vehicles have a top speed.<br /><br />That's simple enough, but how do they go?  A plane flies, a flies, a car drives...<br /><br />But they all go.<br /><br />You can program a Vehicle class to have common things, like top speed.  Then you can say that all Vehicles go, but each individual Vehicle, like a plane, boat or car, must define for itself what that means.<br /><br />And that's the basics of inheritance."}, {question:"I've seen examples online where functions are written inside of functions <i>(this.doSomething = function(){}).</i> How does this work with prototypes?",answer:"Remember that a function is an object and can therefore be assigned to a variable.  You can then invoke (call) that variable as the function.<br /><br />Adding a function to a class inside of the 'class' function creates it for each object instance of that class, but not to the globally stored prototype.  This protects it from being copied (if you want it protected), but it also uses more memory and executes more slowly."}, {question:"Why would I ever make functions inside of classes instead of using the prototype?",answer:"When working with a true object oriented language (like Java), much of the information that is inherent to a class is hidden from objects.  That protects the informationfrom being changed in ways not anticipated by the programmer.  We can mimic that in JavaScript by creating local variables through prototype functions.  You have to have the functions written directly into the body of the class function."}],
    projects: [{title:"Kings In The Corners", text:"Kings in the Corners is a solitaire card game during which the player lays out cards, one at a time off the top of the deck, onto a 4X4 board. Jacks are placed on the sides. Queens are placed on the top and bottom. Kings are placed in the corners. Once 16 cards have been placed and the board filled, the player will begin removing number cards (as appropriate) until no more can be removed. The game is won when all of the face cards have been properly placed and all of the number cards have been removed."}, {title:"Thirty One", text:"The game of Thirty One is a Rummy style card game where players compete to build a 3 card hand of the highest value."}, {title:"Disjunction Wireless", text:"Disjunction Wireless, the 144th highest rated cell phone provider in the town of Small Town, has hired your to create an analysis page.  They have been using the same plans for years and years and years and have come to the conclusion that some of their pricing doesn’t meet customer needs.  Your job is to create a page which reads in the data for the customers and analyzes which plans are best for which people."}, {title:"Human Online Diagnostic Tool", text:"Welcome to your Human Online Diagnostic Tool (HODIT).  HODIT serves the public as a means of quickly diagnosing a problem with your body based on the symptoms and their locations.  As the HODIT programmer, it's your job to build this website from the ground up."}, {title:"Build Your Own Project", text:"You may choose to create a web page/site based on anything you want.  Please create a spec sheet based on the provided template and make sure to give it in for approval <b><i>before</i></b> beginning the project."}]
};