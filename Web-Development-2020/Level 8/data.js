const PAGE_DATA = {
    level: "Level 8",
    title: "Server Side Programming with NodeJS",
    lessons: [{title:"Intro To Server Side Programming", objective:"Objective: To get a feel for server side programming.", description:"HTML, JavaScript, and CSS are used to create client side web pages.  Client side means that the code is loaded onto the user's (client's) machine and run locally in the browser.  All of those pages are stored on a server until a request is sent for them.<br /><br />When the client types a web address into the address bar (or clicks on a link, etc...), a request is sent to the server. the server side script processes that request and generates a response.  That response usually includes the contents of the requested file (an HTML file, a JavaScript file, a CSS file, an image, a .pdf, ...you get the idea).  Once the server sends the response, the file is downloaded to the requestor's machine and loaded into the browser.<br /><br />We are going to work in NodeJS, which is a server side JavaScript language.  The first step is to download and install NodeJS (unless you already have it).<br /><br /><li>Go to <a href = 'https://nodejs.org/en/download'> the NodeJS download page</a> and download the software.</li><li>Select the proper version based on your computer.</li>",slides:[{text:"For this construction, we're just going to get our feet wet with programming something and running it through the server.  Make a new JavaScript file and call it main.js.  Use only the code shown.<br /><br /><b><i>Organizing your server side web sites into their own folders is very important.  Do not drop everything onto your desktop or downloads or documents folder.</i></b>",image:"step1.PNG"},{text:"In order to set up a mock server, we need to use the command line window.<br /><br />NodeJS should set up a shortcut to the command line window when it is installed.  Use this shortcut.<br /><br />The console screen uses old DOS commands.  These commands are <b><i>not</i></b> case sensitive:<br /><br />CD - Change directory allows you to naviagate through the folders on your drive.  It requires you to specify the name of the directory - <i>cd mydir</i><br /><br />MD - Make directory allows you to create new folders on your drive.  It requires you to specify the name of the new directory - <i>md newdir</i><br /><br />DIR - List the contents of the current directory.",image:"step2.PNG"},{text:"You will want to navigate to the folder where you have stored your nodejs file.<br /><br />You can do this by using the CD command from the command line.<br /><br />You can copy the full path from My Computer and then paste it into the command line.  Your full line should look something like:  <i>cd C:\Users\Student 1\NodeJS\First Program\</i><br /><br />You can then execute the file by using the 'node' command and specifying the file: <i>node main.js</i><br /><br />Try it.",image:"step3.PNG"},{text:"Notice how the 'console' now refers to the command line window.  The log function wrote to that window.<br /><br />Remember that, whenever you go online, you are sending requests to the server.  Your service provider is logging all of that activity.  Before we dive in to real server side programming, we need to use the console to understand how the server and the client interact.<br /><br />As you learn this, remember that NodeJS is JavaScript.  Everything you've learned about the language applies to NodeJS.<br /><br />Still, you must reconcile the fact that your server side code is different than your client side code.  By the time your client page loads on the client's machine, your server side code is done and will not execute again unless another request is made to the server.",image:"step3.PNG"}]},
{title:"Blocking and Non Blocking Code", objective:"Objective: To understand the difference between synchronous (linear) code and asynchronous code.", description:"Blocking, or <b><i>synchronous</i></b> code is code that runs in a linear sequence.  Whichever is the next instruction cannot execute until the current instruction is complete.<br /><br />Non-blocking, or <b><i>asynchronous</i></b> code does not run in sequence.  Whatever task your program wants to run can interject itself at any point during the execution.  Non-blocking code can be difficult to debug because different conditions may exist during different executions.<br /><br />In JavaScript, most non-blocking code requires a callback function.  Timers use callback functions.  The functions passed through the timers wait for their moment and then execute regardless of what else is happening within the execution.",slides:[{text:"Let's start with an example of <i>blocking</i> code.<br /><br />Create a JavaScript file in a new folder and type this code into it.<br /><br />Create a text file in the same folder with a couple of lines of text in it and call it 'input.txt'.<br /><br />Run this file using node.",image:"step1.PNG"},{text:"The text from the text file is written to the screen, followed by the 'Program Ended' string.",image:"step2.PNG"},{text:"Let's take a look at the code.<br /><br />The <b><i>require</i></b> function creates an object that is based on a Nodejs package. The package name is passed into the function as a string. The function returns an object that can access that package's properties and functions.<br /><br /><b><i>The reference documentation for Nodejs can be found at nodejs.org.</i></b>",image:"step3.PNG"},{text:"Using the 'fs' object (fs stands for file system, but is just a variable name), we call the function readFileSync.<br /><br />readFileSync takes in the name of a file as the parameter (in this case, input.txt).<br /><br />All the rules of paths and pathnames apply here.<br /><br />The function reads the file and returns the text as a buffer.",image:"step4.PNG"},{text:"A buffer is a container that holds data bytes.  <b><i>It is not text.</i></b><br /><br />In order to convert the data in the buffer to text, we use the buffer to call toString().<br /><br />toString() is a very common function.  It takes the relevant data from an object and generates a string representation of that object.",image:"step5.PNG"},{text:"This code is blocking, or synchronous code.<br /><br />It executes in a top down fashion, with each line having to wait for the previous line to finish before executing.<br /><br />Most of the code we've written up until now has been synchronous code.",image:"step6.PNG"},{text:"Let's shift gears.<br /><br />Here is an example of non-blocking code, which does the same thing.<br /><br />Create this file in a separate folder. Make sure to copy along your text file.<br /><br />Note that we are using readFile instead of readFileSync.<br /><br />readFile takes in an extra parameter and doesn't return anything that we use.",image:"step7.PNG"},{text:"Look very carefully at the execution of this code.<br /><br />What's different between this execution and the execution of the blocking code?",image:"step8.PNG"},{text:"This code shows the Program Ended line before showing the text from the file.<br /><br />This occurs because of the callback function.<br /><br />What other conventions have we used, client side, that required callback functions?",image:"step9.PNG"},{text:"The second parameter in the readFile function is, itself, an anonymous function.<br /><br />This callback function waits until the entire input.txt file is read before executing.<br /><br />While it's waiting, the program moves on to the next line, which logs the 'Program Ended' message.",image:"step10.PNG"},{text:"The callback function for readFile takes 2 parameters.<br /><br />The first, err, is an object designed to receive information about any errors.<br /><br />The second, data, receives the text from the file.",image:"step11.PNG"},{text:"If there's an error, its information will be logged to the screen.<br /><br />Regardless, the text from the text file will be logged from the string.<br /><br />Note that that information was put into data, which is a parameter of the callback function.<br /><br /><b><i>For a more practical example of how this works, check out the Pig Latin code in the samples section.</i></b>",image:"step12.PNG"}]},
{title:"Web Server", objective:"Objective: To set up a Node.js <b><i>listening</i></b> server.", description:"A web server is a program that sits on the server machine and waits for a client request.<br /><br />When the server receives the request, it processes the information in the request and sends a response.<br /><br />The request is sent by typing a web address into the address bar or clicking a link, etc...<br /><br />The response is the text or code the server side script has been programmed to send back.",slides:[{text:"This very simple example of a web server creates the server and has it listen for a request.<br /><br />After processing the request, it responds by saying 'Hello World'.Type this code into a javascript file called webserver.js.<br /><br />Open up the command line window and navigate to the proper directory.<br /><br />Run this file.",image:"step1.PNG"},{text:"Your command line window should appear to have been frozen. It will display the information from the console.log and do nothing else.<br /><br />It is waiting for a request.<br /><br /><b><i>When testing code, you can shut down the running server by using CTRL-C.</i></b>",image:"step2.PNG"},{text:"Let's send the request.<br /><br />Open up your browser window and type the web address shown into the address bar.",image:"step2.PNG"},{text:"Your browser window should now show you the Hello World text.",image:"step3.PNG"},{text:"Let's take a look at the code.<br /><br />The first line creates an http object from the Nodejs package.<br /><br />HTTP stands for hypertext transfer protocol.<br /><br />It is how the pages on the web communicate with each other.",image:"step4.PNG"},{text:"We use the http object to call the createServer function.<br /><br />This function takes, as a parameter, an anonymous callback function that will handle the data coming in from the request and going out to response.",image:"step5.PNG"},{text:"In this example, we're not doing anything with the request and only performing some basic operations with the response.<br /><br />writeHead writes information to the page's header.<br /><br />The end() function tells the server that the response is complete and can be sent to the client.",image:"step6.PNG"},{text:"The first parameter in writeHead is an http status code.  This particular code says that all is okay.  If you were detecting errors, you might send the dreaded 404 code.<br /><br />The second parameter is a JSON object.  Web page headers can have several of these objects.  They look for specific properties, like 'Content-Type' and specific values.",image:"step7.PNG"},{text:"The end() function sends the completed response to the client.<br /><br />All the parameters in the end() function are optional.<br /><br />In this case, we are sending the 'Hello World' message as a parameter.",image:"step8.PNG"},{text:"The createServer function returns a server object.<br /><br />The main purpose of the server object is to listen for and respond to requests.<br /><br />We are using the function call as the object and calling the listen() function.<br /><br />8081 is a port on our local web address.",image:"step9.PNG"},{text:"Though the log function only sends text to the console, we have it reporting our server address.<br /><br />127.0.0.1 is a local address on any computer.  It can also be accessed through 'localhost'.<br ><br />In order to grab our own little corner of that address, we set a port (8081).",image:"step10.PNG"},{text:"This server is the most basic example of what we can do with node.js.<br /><br />It forms a skeleton for building much larger, much more intricate responses.<br /><br />Our skeleton is very static.  If we want our server to be able to respond to our pages, we need them to work with the request parameter as well as the response parameter.<br /><br />The request will hold all kinds of information and your response can be built based on that information.<br /><br />Only after the response is complete will the client side page load.<br /><br />It's very important to remember, when designing your page, that no client side code will run, until the server side request has completed its execution.",image:"step10.PNG"}]},
{title:"Enhanced Web Server", objective:"Objective: To learn how to create a server page that listens and responds to HTML requests.", description:"Working with Node.js is different than working with other server side languages.<br /><br />Most web servers host your pages and handle all of the requests.<br /><br />With Node.js, you need someone to host your code, but you are responsible for handling the requests.  One of the benefits of the this is that you can customize your server to your needs.<br /><br />Another is that you get to work in Javascript, with which you are already familiar.<br /><br />But, what is the request?<br /><br />The request is a notification to the server that you want to run something, but that request should also include information.  <i>What</i> do you want to run?<br /><br />",slides:[{text:"For this construction, we're going to run an HTML page.<br /><br />Copy the following code into a new file called <i>webserver.js</i>.<br /><br />Take one of your early HTML files and copy it into the folder.<br /><br />Run the Nodejs file in command line so that your server is up.  Just like before you'll get the  “Server running” message.<br /><br />Open up your browser and type in the URL.  At the end of the URL, add “/” + the name of your HTML file.<br /><br />Your HTML file should open up in the browser.<br /><br />The difference between loading it this way and loading it directly is that it is now running through your server.  The URL is different than it would be if you had just double clicked your HTML file.",image:"step1.PNG"},{text:"In addition to http, this new web server requires 'fs' and 'url'<br /><br />fs is the file system package and will allow us to read in our HTML file.<br /><br />url receives information from the address bar.",image:"step2.PNG"},{text:"The url object holds all of the data from the address bar.<br /><br />You can parse that data into an object and grab some information.<br /><br />In this case, we are parsing the url property of the request object.<br /><br />That function returns an object whose properties are the parts of the url.<br /><br />We are pulling out the pathname, which begins in our root directory.<br /><br />In this case, the pathname will be the name of the HTML file we are requesting.",image:"step3.PNG"},{text:"This piece of non-blocking code reads in the HTML file and loads the information into the callback function.<br /><br />If there is an error, it will create a 404 error message.<br /><br />Otherwise, it will generate and send a response.",image:"step4.PNG"},{text:"Instead of sending a text message through the end() function, this code writes to the response object.<br /><br />data is a parameter of the callback function and holds all of the information read in from the first parameter of readFile (pathname in this case).",image:"step5.PNG"},{text:"That file is our HTML file, sent through to the request object through the URL.<br /><br />All of the text from the HTML file is stored in the data buffer.<br /><br />We convert it to a string and write it to the response object.<br /><br />You can have multiple write statements if you want to add anything to the HTML.",image:"step5.PNG"},{text:"Notice here that the end() function doesn't have any argument passed through.<br /><br />All of the information sent to the response page has been pre-written so that, when the response is sent, no further information is needed.<br /><br />In the end, this may seem like a more complicated way to do something we already know how to do.  However, consider the implications of being able to load other types of documents this way.  More importantly, consider the implications of being able to interact with these files on the server <i><b>before</b></i> the user even sees them.",image:"step6.PNG"}]},
{title:"Multiple File Types", objective:"Objective: To understand how to work with multiple files using your Node web server.", description:"Every single file that your web page loads needs to pass through the server.<br /><br />It's pretty easy to believe that one HTML file means one file through the server, but your one HTML file can have code that accesses many other files of all different types.<br /><br />For example, if you're using utilities.js, that's another file.  When your HTML file gets to the script tag that imports utilities.js, a request is sent to the server to load utilities.js to your page.<br /><br />Don't worry, this doesn't make any extra work for you.  An HTML file and a Javascript file are both essentially text files.  Therefore, when they get loaded up, they do so in exactly the same way.<br /><br />Image files, however, are a completely different animal.<br /><br />Audio files are a completely different animal.<br /><br />.pdfs are a completely different animal.<br /><br />In fact, there are a lots of different animals out there.",slides:[{text:"For this construction, you will need 3 files:<br /><br />webserver.js<br />index.html<br />content.js (to be created)<br /><br />Put this CSS into your index.html file.",image:"step1.PNG"},{text:"Put this CSS into your index.html file, also.<br /><br />That's the last of the CSS.",image:"step2.PNG"},{text:"And here's all of the HTML.that goes in the body.",image:"step3.PNG"},{text:"Let's start writing some javascript inside the script tag.  We're going to work with an array of images.  These images are included in the <a href = 'lessons/multiple file types/heroes gallery.zip'>Heroes Gallery zip file</a>.  You can extract that right into your root directory.  Using the array, we will build the image elements dynamically rather than having to type them all into the HTML.",image:"step4.PNG"},{text:"initialize() does what initialize() always does.  There are 2 HTML elements with which we need to interact.  They are stored in variables.<br /><br />The source of the main image is set to whatever is first in the array.  This gives us a main image right away without the user having to click something.<br /><br />The final line is a call to buildThumbnailElements(), which will create the img elements and add them to the page.",image:"step5.PNG"},{text:"The functiom buildThumbnailElements() will loop through each of the images in the THUMBS array.",image:"step6.PNG"},{text:"Create the image element and store it into a temporary Javascript variable (local).<br /><br />Set the src of the image to match the indexed item from THUMBS.<br /><br />Because we have placed all of our images into an 'images/' folder, that needs to be concatenated onto the src.<br /><br />If you <b><i>haven't</i></b> placed your images into an 'images/' folder, you will need to update your code accordingly.",image:"step7.PNG"},{text:"Every image needs a click event assigned to it.<br /><br />All the embeddded callback function does is assign the src of the clicked image (this) to the src of the main image so that the main image changes.",image:"step8.PNG"},{text:"Finally, add the new img element to the div and we're done.<br /><br />Really.<br /><br />You can run this directly from your editor or your drive and it will work.<br /><br />Once you make sure it works, though, let's get it running off of a server.",image:"step9.PNG"},{text:"If we want our server to respond to different types of files, we need to tell it what to expect.<br /><br />This is an array of JSON notation objects that describes what types of files come with what extensions.<br /><br />We'll use this array to look up file types and inform our webserver of the results.<br /><br />Put this into the 'content.js' file.",image:"step10.PNG"},{text:"If we want to use this particular utility file over and over again (and we do), we should do all of the heavy lifting here.<br /><br />The getFileTypeObject() function is going to take in an extension as a parameter and return the matching object from CONTENT_TYPES.<br /><br />Creating a function for use through a Node.js utility file is a little different from using client side Javascript.  Since Node.js files are 'required' and stored in objects, the functions and variables that are exported must be created as objects and added as members of 'exports'.<br /><br />If you didn't notice before, we did <b><i>not</i></b> do that with the CONTENT_TYPES array.  That's because CONTENT_TYPES will be used <b><i>only</i></b> in this file and should be inaccessible to other files.",image:"step11.PNG"},{text:"All we need to do inside the function is loop through the CONTENT_TYPES objects and return the one we find.<br /><br />We can update the array with new types of files in order to build a more complete and useful utility as we gain more experience.",image:"step12.PNG"},{text:"This is webserver.js.  You should be able to lift it right out of the last tutorial.  We're going to make some changes to it, but make sure it starts off looking exactly like this one.",image:"step13.PNG"},{text:"The first thing we need to do is include the content.js file on our server.  This is done with a 'require' statement, just like we did with all of the included node packages.  We create an object and assign it the exported object returned by the require statement.<br /><br />Note the difference in the argument, though.  Since we are requiring one of our own files, we need to let our page know that it's in our own directory structure.  That's what the './' does.",image:"step14.PNG"},{text:"The next step is to use the function we wrote in content.js and grab that file type object.  We can use some string manipulation to grab the file extension from the pathname.  Then we pass it into the getFileTypeObject() function and get back our contentType.",image:"step15.PNG"},{text:"Change the writeHead() calls so that the argument now represents whatever file and file type is being requested.<br /><br />NOTE that your webserver is becoming more and more abstract, which makes it more capable of handling any type of web page.  Node.js pages work off of servers built in Node.js.  It's very helpful if you have something you can just plug in wherever you need it.",image:"step16.PNG"},{text:"The final piece of this puzzle is what to do with the files after they are read in.  If there's an error, it doesn't matter.  That code stays the same.<br /><br />If there's no error, we have to write the data differently for different files.  Only text files work with the toString().  That text is copied directly to your HTML page and does what it's written to do.<br /><br />Other types of files are transferred in binary (passed through the write() function as a string).  Your page interprets the binary data from the file and parses it in whatever way it needs to be parsed.<br /><br />Load up your web server now and run your index.html through it.  It will work exactly the same way as it did when running it through the client, but the log in the command line window will show you which requests are made as they are made.<br /><br />",image:"step17.PNG"}
]},
{title:"AJAX", objective:"Objective: To get a feeling for asynchronous server requests.", description:"AJAX stands for <b><i>Asynchronous JavaScript and XML</i></b><br /><br />In the old days, you could only get data from the server when you loaded a page from scratch.  If you wanted to send data back to the server or receive more data, you either needed to reload the page or load a whole new page.<br /><br />A whole lot of this was done through the use of forms, which were specifically designed for this purpose.<br /><br />Somewhere, somewhen, someone decided that they wanted to send information to the server and receive information from the server and keep right on rolling along with their current page. They decided that they could put all of the information into an XML (eXtensible Markup Language) file and just read it from the server that way.<br /><br />Thus, AJAX was born.<br /><br />Since those days, AJAX, which doesn't really use the X as much anymore, has become a way to simply access the server asynchronously.<br /><br />Remember that asynchronously means that processes are operating independently of one another.  Process A is doing its thing while Process B is doing its thing. That means the server can handle your request and the client can keep doing whatever it's doing.",slides:[{text:"For this construction, we're going to further enhance our image gallery.  Copy all of those files over to a different folder.<br /><br />The goal here is to get rid of the hard coded images.  Instead, the client is going to <b><i>ask</b></i> the server which images are sitting in the folder and include <b><i>all</i></b> of them in the gallery.<br /><br />The code presented here is how your initialize() function should look.<br /><br />We won't need the list of images because that information will come directly from the drive.  We also can't populate the screen because we don't have all of the information yet.",image:"step1.PNG"},{text:"The loadImages() function is your gateway to the server.<br /><br />It is designed to create and execute an XHR (XML Http Request), which is the foundation of AJAX.<br /><br />This program will only use one, but you may need to make multiple requests to the server, which require multiple functions.",image:"step2.PNG"},{text:"The first piece is this XMLHttpRequest object.<br /><br />The XHR is built from several properties and functions that facilitate making the server request.",image:"step3.PNG"},{text:"The first thing we do is open the rquest with the open() function.<br /><br />The first parameter is a string representing the <b><i>method</i></b> for transfer.  We're using 'GET'.  The other common method is 'POST'.  When using forms, POST was always more secure than GET because, with GET, information appears in the URL.  Tha's not really relevant here because the URL never shows up in the user's browser.<br /><br />The second parameter is the request itself.  We are accessing the server and port we specifiy in our webserver.<br /><br />The last piece, 'getImages' is our designation for the code we want to run.",image:"step4.PNG"},{text:"The XHR has a readyState property that goes through various changes throughout the process.<br /><br />The readyState values range from the request being made to the request being sent, processed, and returned (readyState == 4).",image:"step5.PNG"},{text:"onreadystatechange is an event listener built into the object.<br /><br />It triggers every time the readyState property changes.<br /><br />We can assign a response to that event through the use of a callback function.<br /><br />Here, the function is declared anonymously and fleshed out right on the spot.<br /><br />You can also create an external function and reference it by name, but I have found that doing it anonymously prevents conflicts with other external calls.",image:"step5.PNG"},{text:"What we do inside the function can (and should) depend on the readyState of the request.  For our purposes, the only readyState that matters is completion (4).<br /><br />In another program, you might wish to display a counter or have some other reactions to the different readyStates.",image:"step6.PNG"},{text:"The code inside the condition has a lot to do with what happens on the server.<br /><br />The important part here is that the information we get back from the server comes to us through the XHR property responseText.",image:"step7.PNG"},{text:"The data <b><i>always</i></b> comes through as a string.<br /><br />You'll notice that this code splits the string around commas.  Later on, you'll see that the information is designed to be comma delimited.",image:"step7.PNG"},{text:"The last line is the call that we moved from initialize().<br /><br />We moved it because we no longer have the names of the images in the client.  We need that from the server.<br /><br />We also added a parameter because we need to pass through the information from the server.",image:"step7.PNG"},{text:"The send() function call is coded after everything is put into place, but the readyState won't change until the request is sent.",image:"step8.PNG"},{text:"The buildThumbnailElements() function is almost identical to the original.<br /><br />The parameter has been added and is used instead of the THUMBS constant array.",image:"step9.PNG"},{text:"In webserver.js, we've added a require statement.<br /><br />The clientdata.js file will have the function that directly responds to our “getimages” request.",image:"step10.PNG"},{text:"This is clientdata.js.<br /><br />All of it.<br /><br />This is where we handle the specifics of what our AJAX request wants.",image:"step11.PNG"},{text:"Notice that clientdata.js has its own require statement.<br /><br />The 'fs' file stands for file system.  The functions in here will give us access to the directory listing.",image:"step12.PNG"},{text:"We create a function (getClientData) using the exports convention that we learned in the last tutorial.<br /><br />The pathname is a parameter.<br /><br />When we look at webserver.js, we'll see that the pathname is pulled directly from the request.<br /><br />Remember that the end of our request URL was 'getimages'?",image:"step13.PNG"},{text:"We can use the clientdata.js file to handle multiple requests.<br /><br />We can simply have multiple conditions, each responding to a different pathname.<br /><br />There are other ways to handle this using data structures (an array of functions, etc…), but we'll stick with conditions for the time being.",image:"step13.PNG"},{text:"Once we've identified the request, we can begin responding to it.<br /><br />The readdirSync() function reads the list of files from a specified folder.<br /><br />The folder is passed into the function as a string.",image:"step14.PNG"},{text:"The information that is returned comes back to us in a buffer, which is essentially an object designed to hold data.<br /><br />In order to transform that buffer into a usable format, it needs to be converted to string data.<br /><br />The toString() function does that.  <i>And</i> it's comma delimited.",image:"step14.PNG"},{text:"Let's look at webserver.js.<br /><br />Keep in mind that this code is evolving.  As we develop a more abstract and modular way of interacting with our web pages, we will adapt and add more code to our server.",image:"step15.PNG"},{text:"In the old version, we jumped right into reading the file from the request.<br /><br />Now, the request may not include a file.<br /><br />Our 'getimages' request is not about loading a file, but about just getting information.",image:"step16.PNG"},{text:"Because of that, we need to get the extension beforehand.<br /><br />If there is no file in the request, then there will be no dot (.).<br /><br />That means that the substring will return the pathname itself as the extension.",image:"step17.PNG"},{text:"If that's the case, we can send the response right away.<br /><br />Remember in our early servers, the end() function took a string parameter and returned that to the page.<br /><br />That's what's happening here.<br /><br />We are calling the getClientData function and passing through the pathname ('getimages').<br /><br />getClientData() will return the requested information and we'll pass it back to the page.<br /><br />The responseText property of the XHR will receive that information.",image:"step18.PNG"},{text:"The rest of this file encompasses the code we already have.  If there's a legitimate extension on the request then it is, in fact, a file, and we need the server to read it.<br /><br />",image:"step19.PNG"}]},
{title:"Reading Text Files", objective:"Objective: To see how we can read information from a plain text file.", description:"Working with data is what computing is all about.<br /><br />Companies invest heavily in data solutions and the people who can provide them with those solutions.<br /><br />While we're not working with a database here, learning to arrange your data in text files and objects is a good place to start understanding big data concepts.",slides:[{text:"For this construction, we're going to make a server side data gallery.  We'll be rebuilding the data gallery as a dynamic page that can read in information from a text file and display it.<br /><br />All of the necessary files have been included in the <a href = 'lessons/reading text files/ssdatagallery.zip'>Server Side Data Gallery Files Zip File</a>.<br /><br />This is all of the HTML.  You'll notice that there isn't character of text or one indication of a gallery image.  All of that information will come from the server.",image:"step1.PNG"},{text:"You'll need to link these 3 CSS files to your HTML file in order to make use of the classes detailed in the HTML.<br /><br />These files are included in the zip file.<br /><br />The order of the listing is important.<br /><br />After you are done, take some time to look at the layout of the items on screen and review the CSS in these files.",image:"step2.PNG"},{text:"Much of the Javascript code will be similar to the data gallery you constructed before.<br /><br />This one has a dynamic background image.<br /><br />Rather than use the CSS background-image properties, it's been placed on the page as an element.<br /><br />The CSS for this is in dressing.CSS and gallery.CSS.",image:"step3.PNG"},{text:"currentItemIdx will keep track of which item is currently selected.<br /><br />offset is used to figure out which three items to show in the display.<br /><br />Notice that getData() is called at the end of the function.<br /><br />getData() is our AJAX request.  Without it, our gallery is empty.",image:"step4.PNG"},{text:"Before moving on to the AJAX, let's put in all of the basic Javascript.<br /><br />The selectItem() function is triggered whenever the user clicks on one of the thumbnails (check the HTML).<br /><br />It works entirely in the back end, setting the currentItemIdx.<br /><br />Remember that the user only sees 3 thumbnails no matter how many images are in the gallery.<br /><br />The offset tells the program which image in the list is the first of the 3.<br /><br />Adding that number to the idx (which is 0-2) gives us the right image.",image:"step5.PNG"},{text:"moveOffset() is triggered whenever the user clicks on an arrow.<br /><br />Our page passes either 1 or -1 into mod, but the function could handle any modifier if we wanted to program a 'fast forward' or backward arrow.<br /><br />The offset is adjusted accordingly (making sure not to go below 0 or past the end of the array).<br /><br />The data object is filled in the getData() function, which we haven't seen yet.",image:"step6.PNG"},{text:"setThumbnails() figures out which images are supposed to be shown as the 3 thumbnails.<br /><br />It starts at the beginning of the array of img elements and fills them in from the back end data.<br /><br />It uses the offset to choose the 3 images.<br /><br />This function works in conjunction with moveOffset() to make sure that 3 images are always shown and there are no errors.",image:"step7.PNG"},{text:"Finally, the display() function looks at all of the relevant back end information and updates the screen for the user to see.<br /><br />Note that the background image is altered to match the main image of whatever has been selected.",image:"step8.PNG"},{text:"Now the fun part.<br /><br />getData() sets up an AJAX request to our web server.<br /><br />Notice that the URL in the dataRequest.open() function specifies getData with no extension.  This will work with some of the Node.js code we created in the last lesson.",image:"step9.PNG"},{text:"Take a moment to look at itemdata.txt, which has been included for you.<br /><br />This file is plain text and has been designed as a series of JSON objects.<br /><br />Each object begins with a brace ({) and ends with a brace (}).<br /><br />The objects are separated by semicolons (;).<br /><br />Each object has the name, info, and imgfile properties and their accompanying values.",image:"step10.PNG"},{text:"Now let's jump back into getData() and have a look at what happens when the readyState hits 4.<br /><br />The responseText will come back as a string made up of all of the text from itemdata.txt.<br /><br />Since all of the JSON objects are separated by semicolons, we split that string into an array of those objects.",image:"step11.PNG"},{text:"Even though the items in the array will look like JSON objects, they're still strings.<br /><br />We need to convert each one into an actual object.<br /><br />Fortunately, there's a built in Javascript function for that.<br /><br />JSON.parse() takes in a JSON looking string and returns an object.<br /><br />We're taking that object and putting it right back into the array, overwriting the original string.",image:"step12.PNG"},{text:"When all of that work is done, call setThumbnails() in order to fill in all of the proper back end information.<br /><br />Then call display() to display it.",image:"step13.PNG"},{text:"Now it's time to adjust webserver.js.  Start with your old one as it's got most of what we need.  There's always room for adjustment, though.<br /><br />The first thing we do here is set a whole lot of Access-Control headers.  These give permissions to your server including where the request comes from, what methods are allowed, what type of content, and what credentials are necessary.<br /><br />Our headers are set to basically fling open the doors so we can just work with text files unimpeded.  If you were to write and publish something, you'd want to brush up on your security protocols and be more selective.",image:"step14.PNG"},{text:"There's one more adjustment to webserver.js.  Beyond this, everything else is identical to previous versions.<br /><br />When we load a page from the web, such as mlb.com, we don't specifiy a filename.  The server just looks for index.html.<br /><br />Apache servers are coded to do that automatically.  We can code our webserver to do it as well.<br /><br />These two lines of code check to see if a pathname was not specified.  If that is the case, we look for index.html.",image:"step15.PNG"},{text:"The last thing to change is clientdata.js.<br /><br />This file will always  change.  This file is meant to change so that our webserver.js doesn't really have to.<br /><br />It handles all of our specifics.",image:"step16.PNG"},{text:"For the getdata request, we read in all of the information from itemdata.txt and return it.<br /><br />The readFileSync() function reads in data, even text, as a binary buffer.<br /><br />Calling the toString() function with that information converts it to a plain text string.<br /><br />The data is returned to the web server, which sends it as a response to the AJAX request.  The client side JavaScript parses the data into objects and makes our data gallery.",image:"step17.PNG"}]},
{title:"Writing Text Files", objective:"Objective: To transfer data from a client side web page to a text file on the server.", description:"During the pioneer days of web programming, forms were the primary way of transferring data from client to server.  Every time you submitted data with a form, though, a new page would have to load into your browser and that was really slow.<br /><br />AJAX changed all of that.  You could send and receive data to and from the server without having to reload a page.<br /><br />That doesn't mean forms are obsolete. They've been useful in organizing control elements and they are still useful in sending data to the server.",slides:[{text:"For this construction, we're going to build a page that allows a user to write and save text posts.<br /><br />You may use your webserver.js from the previous construction.  There will be no changes to that file.  I mean, that's the point, right?  We've been developing a portable webserver file.  You may need to update it in the future so that it can handle larger projects, but it should work as is for anything at this level.<br /><br />So we can start with the HTML.<br /><br />The form acts as a container for our controls.  Notice that the 'submit' button is <i>inside</i> the form and a type of input tag.",image:"step1.PNG"},{text:"The 'method' attribute is used to tell the page how to transfer the data.<br /><br />A 'post' method indicates that the data should be hidden.<br /><br />A 'get' method would create a query string, showing the data in the URL.<br /><br />",image:"step2.PNG"},{text:"We've used the name attribute to access individual controls within the form, but 'name' takes on a more important role here.<br /><br />When the data is transferred to the server, it will be transferred by name.<br /><br /><b><i>Calling the texarea 'post' has nothing to do with the method attribute.  We're calling it that because it's the message the user is posting.<i></b>",image:"step3.PNG"},{text:"The submit button will always trigger whatever is specified in the 'action' attribute in our form.<br /><br />More often than not, the value of the 'action' attribute is another web page, but we don't need that with our Node.js server so we've left out the action attribute.<br/><br />We're just using the button to call our postText() function.",image:"step4.PNG"},{text:"Our initialize function is comprised of a single line of code.<br /><br />This is a really small program.<br /><br />We are grabbing the form element and putting it into an HTML object.  The form element is all we need.",image:"step5.PNG"},{text:"AJAX!<br /><br />The process for making a request to the server is the same, but now we need to send more than just the name of the request.",image:"step6.PNG"},{text:"Instead of embedding the URL directly into the open() function call, let's make it a local variable.<br /><br />It's easier to build.",image:"step7.PNG"},{text:"Like all of the others we've worked with, it queries the server and has a request name, 'post' (also not associated with the method attribute in the form).<br /><br />In this request, however, we're building a query string so that we can pass our data.",image:"step8.PNG"},{text:"A query string starts with a question mark (?) and is then composed of property and value pairs.<br /><br />The format is 'property=value'.<br /><br />The property name comes from the name of the control element.",image:"step9.PNG"},{text:"Notice how we can access those elements directly through the postForm object.<br /><br />Each pair is separated by an ampersand (&).<br /><br />With all of these pieces, we can build a query string and complete URL.",image:"step10.PNG"},{text:"Since we're writing data instead of reading it, we don't have to do anything with the responseText when the request is complete.<br /><br />Instead, we just empty the fields so that the user can enter a new post.",image:"step11.PNG"},{text:"Create a new clientdata.js file. This is the file that changes a lot because it's the one that's designed to handle the specific requests of your project. When you build something from scratch, you may often need to build this from scratch. When you add to a web site, you will be able to just add to this file as it is designed to work with your webserver.<br /><br />For this page, we'll be using 'fs' for files and 'qs' for the query string.",image:"step12.PNG"},{text:"This is our getClientData() function.<br /><br />This function, which we export, is the basis of all of our clientdata.js files.",image:"step13.PNG"},{text:"One of the changes that's been made is the addition of a parameter.<br /><br />The pathname has always been important because it includes the name of the request.<br /><br />The request, though, gives us the information from the query string.<br /><br /><b><i>Remember when I said you wouldn't have to update the webserver.js file.  It turns out that was false information.  You need to go back and pass in the request object to this function.</i></b>",image:"step14.PNG"},{text:"Here a local variable <b><i>qdata</i></b> has been created.<br /><br />It gets its value from a call to the function parseQueryString(), which takes in the request as an argument.<br /><br />Where does that function come from?",image:"step15.PNG"},{text:"Here it is! Just add it to clientdata.js.<br /><br />This is a simple function that works with the request object and returns the query string as a JSON object.<br /><br />That's what parse() does.  It takes strings in JSON format and turns them into objects.<br /><br />Note that this function is not exported.  That makes it private.  It can only be called from within clientdata.js.",image:"step16.PNG"},{text:"The heart of this program is appending the post to a text file.<br /><br />The appendFile() function takes in 3 arguments:<br /><br />The name of the file<br />The text to append<br />A callback function.",image:"step17.PNG"},{text:"If the specified file does not exist, appendFile() will create it.<br /><br />Otherwise, appendFile() will append (add to the end) all of the text specified in the second parameter.<br /><br />When the appending is done, the callback function is executed.<br /><br />You can try this and then check the text file to make sure it's being updated.<br /><br />If you want to challenge yourself, update the program so that the web page shows all of the posts on screen.",image:"step17.PNG"}]}],
    samples: [{title:"Pig Latin", lesson:"Blocking and Non-Blocking Code", text:"Pig Latin is a way altering the way we say words so that it sounds like a different language.  This program takes in a sentence from a text file and converts it to Pig Latin."}, {title:"Scavenger Hunt", lesson:"Writing Text Files", text:"The Scavenger Hunt program works with a series of text files to create a house full of items.  As a user, you have to move from room to room looking for your goal.  Once you find it and pick it up, you're given a new goal."}],
    faq: [{question:"How do I get my client side JavaScript to interact with my Node.js code?",answer:"There are 2 answers to this question.<br /><br />The first answer is that you can't.<br /><br />The second answer is <i><b>AJAX</b></i>.<br /><br />The server side code and the client side code run independently of each other.  That means, basically, that you can't use Node.js to do a getElementById().  There's no document.<br /><br />The other side of that coin is that, if your client side program needs information from the server, you can use AJAX to request that information directly.  Then your client page can do whatever you need it to do with that information."}],
    projects: [{title:"Mad Libs", text:"A Mad Libs is a story where several words are left out.  The player sees just the types of words they need to fill in (nouns, verbs, adjectives, places in Europe, etc…).  Once they’re done filling in the words, they get to see the story with their words filled in.  It’s hilarious!"}, {title:"Text Adventure Game Engine", text:"Create a web page for building Text Adventure Games.  Text Adventures are games that are essentially interactive books.  They contain multiple story blocks and feed new blocks to the player based on the commands the player gives to the game.<br /><br />A true Text Adventure is more than a simple Choose Your Own Adventure story book.  The player, while limited in the number and types of moves they can make, is not given choices.  Instead, the player must puzzle out the proper commands for each area in the game."}, {title:"What Are We Doing Social Media Platform", text:"The What Are We Doing? social media platform is a place for people to post their on the minute activities and thoughts.  It’s designed for quick access and easy posting.  People can, at any moment, share their activities and their thoughts with the rest of the world while on the go."}, {title:"Virtual Pet", text:""}, {title:"Build Your Own Project", text:"You may choose to create a web page/site based on anything you want.  Please create a spec sheet based on the provided template and make sure to give it in for approval <b><i>before</i></b> beginning the project."}]
};